<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Generador de círculos para Minecraft</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; margin: 20px; }
    .panel { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    label { display: flex; gap: 8px; align-items: center; }
    input[type="number"] { width: 90px; }
    canvas { border: 1px solid #888; background: #f7f7f7; image-rendering: pixelated; }
    .legend { display: flex; gap: 16px; margin-top: 8px; align-items: center; }
    .swatch { width: 16px; height: 16px; border: 1px solid #000; }
    .grid-swatch { background: #dcdcdc; }
    .block-swatch { background: #2b8a3e; }
    .border-swatch { background: #0b7285; }
    .info { margin-top: 8px; font-size: 0.95rem; }
    button { padding: 8px 12px; }
    .tips { margin-top: 8px; color: #555; }
  </style>
</head>
<body>
  <h1>Generador de círculos para Minecraft</h1>

  <div class="panel">
    <label>
      <span>Diámetro (1–512):</span>
      <input id="diameter" type="number" min="1" max="512" value="32" />
    </label>
    <label>
      <span>Modo:</span>
      <select id="mode">
        <option value="outline">Contorno</option>
        <option value="filled">Relleno</option>
      </select>
    </label>
    <label>
      <span>Mostrar cuadrícula:</span>
      <input id="showGrid" type="checkbox" checked />
    </label>
    <label>
      <span>Escala:</span>
      <input id="scale" type="range" min="4" max="24" value="12" />
      <span id="scaleVal">12px/bloque</span>
    </label>
    <button id="renderBtn">Generar</button>
    <button id="downloadBtn">Descargar PNG</button>
  </div>

  <div class="legend">
    <div class="swatch grid-swatch" title="Cuadrícula"></div><span>Cuadrícula</span>
    <div class="swatch block-swatch" title="Bloque (relleno)"></div><span>Bloque</span>
    <div class="swatch border-swatch" title="Bloque (contorno)"></div><span>Contorno</span>
  </div>

  <div class="info" id="infoText">Bloques: —</div>
  <canvas id="canvas" width="768" height="768"></canvas>
  <div class="tips">
    Consejo: el valor es el diámetro en bloques, como en los generadores clásicos. Si necesitas un círculo que cubra de x=a a x=b, recuerda sumar 1 al contar bloques para abarcar ambos extremos.
  </div>

  <script>
    const diameterInput = document.getElementById('diameter');
    const modeSelect = document.getElementById('mode');
    const showGridChk = document.getElementById('showGrid');
    const scaleRange = document.getElementById('scale');
    const scaleVal = document.getElementById('scaleVal');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const infoText = document.getElementById('infoText');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

    function drawGrid(cell) {
      ctx.strokeStyle = '#cccccc';
      ctx.lineWidth = 1;
      const w = canvas.width, h = canvas.height;
      ctx.beginPath();
      for (let x = 0; x <= w; x += cell) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
      for (let y = 0; y <= h; y += cell) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
      ctx.stroke();
    }

    // Determina si la celda (i,j) está en el contorno o dentro usando distancia al centro
    function computeMask(d, mode) {
      const cx = (d - 1) / 2;
      const cy = (d - 1) / 2;
      const r = d / 2; // diámetro -> radio
      const mask = Array.from({ length: d }, () => Array(d).fill(false));
      let count = 0;

      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
          const dx = i - cx;
          const dy = j - cy;
          const dist = Math.sqrt(dx*dx + dy*dy);
          // Umbral de contorno para pixel-perfect en rejilla
          const onBorder = Math.abs(dist - r) <= 0.5;
          const inside = dist <= r + 0.5;

          const use = (mode === 'outline') ? onBorder : inside;
          if (use) { mask[i][j] = true; count++; }
        }
      }
      return { mask, count };
    }

    function autoScaleForDiameter(d) {
      // Intenta encajar el círculo en el lienzo
      const maxCanvas = Math.min(window.innerWidth - 40, 1024);
      canvas.width = maxCanvas;
      canvas.height = maxCanvas;
      const target = Math.floor(maxCanvas / d);
      return clamp(target, parseInt(scaleRange.min), parseInt(scaleRange.max));
    }

    function render() {
      let d = parseInt(diameterInput.value, 10);
      d = clamp(d, 1, 512);
      diameterInput.value = d;

      // Ajuste de escala (auto si no cabe)
      let cell = parseInt(scaleRange.value, 10);
      const needed = d * cell;
      if (needed > canvas.width || needed > canvas.height) {
        cell = autoScaleForDiameter(d);
        scaleRange.value = cell;
      }
      scaleVal.textContent = `${cell}px/bloque`;

      // Redimensiona canvas al tamaño necesario
      const sizePx = d * cell;
      canvas.width = sizePx;
      canvas.height = sizePx;

      // Limpia
      ctx.fillStyle = '#f7f7f7';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Dibuja cuadrícula si procede
      if (showGridChk.checked) drawGrid(cell);

      // Calcula máscara y pinta
      const { mask, count } = computeMask(d, modeSelect.value);
      infoText.textContent = `Bloques: ${count} (${modeSelect.value === 'outline' ? 'contorno' : 'relleno'}) • Diámetro: ${d}`;

      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
          if (!mask[i][j]) continue;
          const x = i * cell, y = j * cell;
          ctx.fillStyle = (modeSelect.value === 'outline') ? '#0b7285' : '#2b8a3e';
          ctx.fillRect(x, y, cell, cell);
          // Opcional: borde de cada bloque para claridad
          ctx.strokeStyle = '#555';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, cell, cell);
        }
      }
    }

    function downloadPNG() {
      const a = document.createElement('a');
      a.download = `minecraft-circle-d${diameterInput.value}-${modeSelect.value}.png`;
      a.href = canvas.toDataURL('image/png');
      a.click();
    }

    renderBtn.addEventListener('click', render);
    downloadBtn.addEventListener('click', downloadPNG);
    scaleRange.addEventListener('input', () => {
      scaleVal.textContent = `${scaleRange.value}px/bloque`;
      render();
    });
    diameterInput.addEventListener('input', render);
    modeSelect.addEventListener('change', render);
    showGridChk.addEventListener('change', render);

    // Primera render
    render();
    // Re-render en cambio de tamaño de ventana
    window.addEventListener('resize', render);
  </script>
</body>
</html>
